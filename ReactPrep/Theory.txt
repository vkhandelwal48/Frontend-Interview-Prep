How React Updates the Website UI

1-> Creating a Component Tree
2-> Creating Virtual Snapshot of the target HTML Code.
3-> Compare New Virtual DOM snapshot to Previous(Old) Virtual DOM Snapshot.
4-> Identify & apply changes to the "Real DOM".

Keys

-> if we use index here instead of unique id then when two items
   are added or removed from the start of the list, all items will
   re-render because their indices will change and React will think
   that they are different items.

-> It also helps in state preservation of HistoryItem components
   when items are added or removed from the list.
   e.g. if we select an item and then add a new item at the start,
   the selected item will remain selected because its key (id)
   remains the same.
-> If we had used index as key, the selected item would have changed
   because all indices would have shifted.

server side rendering in React
Server-Side Rendering (SSR) in React is the process of rendering React components on the server
and sending the fully rendered HTML to the client. This approach improves performance, SEO, and
initial load times by delivering a complete HTML page to the browser, allowing it to display content
before the JavaScript bundle is fully loaded and executed.

React Performace
1) Use Memo and UseCallback
2) Virtual Lists
3) Lazy Loading
4) Pure Components
5) React.memo
6) use key props properly
7) Avoid inline functions in render when possible

Strict Mode in React

1) Identifying components with unsafe lifecycle methods
2) Warning about the usage of findDOMNode
3) Warning about the usage of legacy context API

Batching in React
Batching in React refers to the process of grouping multiple state updates into a single render cycle.
This optimization reduces the number of re-renders and improves performance by minimizing the
amount of work React needs to do when updating the UI. React automatically batches state updates
that occur within event handlers and lifecycle methods, ensuring that the component only re-renders
once after all updates have been processed.

Example of Batching
let count=0;

function updateCount(){
    count+=1;
    console.log("vidit1");
}

function handleClick(){
    updateCount();
    updateCount();
    updateCount();
    console.log("vidit2");
}

handleClick();

function App() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState('noUser'); 
  
  const handleClick = () => { 
    setCount((count) => count + 1);
    setUser('Vidit'); 
    setCount(42);
  }
  return (
  <div>
    <h1>Hello, World!</h1>
    <div>
      <button onClick={handleClick}> count {count} </button> 
    </div>
  </div>
  ) 
}
export default App;

explain the whole rednering cycle here

handleClick function is called when the button is clicked.
Inside handleClick, setCount is called twice and setUser is called once.
React batches these state updates together for performance optimization.
After batching, React determines the final state values: count becomes 42 and user becomes 'Vidit'.
React then triggers a re-render of the component with the updated state values.
The component re-renders, and the UI reflects the new count value of 42.

const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
}

in this case if we click the button count will be incremented by 1 only because
React batches the state updates and uses the value of count at the time of the click event for all updates.
So, if count was 0 when the button was clicked, each setCount call effectively becomes setCount(0 + 1).
As a result, after all four calls, count will be set to 1.
To achieve the desired behavior of incrementing count by 4 with each click, you can use the functional form of setState:
const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
}

In this example, when handleClick is called, updateCount is invoked three times.
However, due to batching, the console will log "vidit1" three times followed by "vidit2".
The final value of count will be 3, but the UI will only re-render once after all updates are complete.

useRef Vs createRef
Are used to access DOM elements or persist mutable values.
Don't trigger re-renders when the .current value changes.
But they differ in when and how they're created and used.

useRef                      | createRef
Functional Components      | Class Components
Same ref across renders   | New Ref on each render

What do we need for JSX to be rendered correctly in a browser?
A transpiler such as Babel to transform JSX to regular JS.

React Portals
React Portals let you render a subtree of React components into a DOM node
that exists outside the DOM hierarchy of the parent component. They are the
official way to mount things like modals, tooltips, dropdowns, and toasts where
DOM placement(z-indez, overflow) matters.

Is there any way we can access the child components state in the parent component ?
a. using callback functions
b. using Refs with forwardRef & useImperativeHandle
c. Lifting state Up (move state from child to parent and then pass to child)

ForwardRef
ForwardRef is a React utility that lets a parent component pass a ref down
to a child component, so that the parent can directly access a DOM node or
a method inside the child.

repaint vs reflow
Reflow (Layout):
1) Reflow is the process of recalculating the layout of the entire webpage or a portion of it.
2) It occurs when changes are made to the DOM that affect the size, position, or structure of elements (e.g., adding/removing elements, changing element dimensions, modifying CSS properties like width, height, margin, padding).
3) Reflow is a more expensive operation in terms of performance because it requires the browser to recalculate the positions and sizes of elements and potentially re-render parts of the page.

Repaint (Redraw):
1) Repaint is the process of updating the visual appearance of elements on the screen without changing their layout.
2) It occurs when changes are made to the visual properties of elements (e.g., changing colors, visibility, background images) that do not affect their size or position.
3) Repaint is generally less expensive than reflow because it only involves updating the pixels on the screen without recalculating the layout of elements.

Pure Component in React
A Pure Component in React is a component that implements a shallow comparison of props and state to determine whether it should re-render.
If the props and state have not changed, the Pure Component will not re-render, which can lead to performance optimizations by reducing unnecessary renders.
Instead of re-rendering every time parent renders, a PureComponent re-renders only if its props or state change (shallow comparison).
It adds a built in shouldComponentUpdate() method that performs this shallow comparison automatically.

when to now use Pure Component
1) When props or state are complex objects or arrays that may change frequently.
2) When the component relies on external data or context that may change independently of props or state.
3) When the component has side effects or relies on lifecycle methods that need to be executed on every render.
4) When the performance gain from using PureComponent is negligible compared to the added complexity it introduces.

What is Webpack?
Webpack is a module bundler for Javascript applications.
It takes all you project's files(Javascript, HTML, CSS, images) etc. and bundles them into
optimized outfiles that browser can load efficiently load.

Bundle Splitting
When you build a modern web app (React, Vue, Angular, etc.),
your bundler (like Webpack, Vite, Rollup, Parcel) combines all your JS, CSS, etc. into a bundle.

Critical Path Rendering
The Critical Path Rendering is the sequence of steps the browser takes to convert HTML, CSS, JavaScript into
pixels on the screen.

Steps in the Critical Rendering Path

1) HTML Parsing -> DOM
a. Browser Parses HTML to build Document Object Model.
b. If it encounters an external stylesheet or script, it may pause parsing.

2) CSS Parsing -> CSSOM
a. Browser downloads all CSS files.
b. Builds the CSS Object Model (rules for each node).

3) Combine DOM + CSSOM -> Render Tree
Browser merges both trees to know what to paint and how it looks
Hidden elements(display:none) are excluded.

4) Layout (Reflow)
Calculates position and size of each element on screen.

5) Paint
Fills pixels into the screen based on layout and styles.

Web Workers
Web Workers allow Javascript code to run in a background thread, separate from the main(UI) thread.

How They Work
The main thread creates a worker.
The worker runs in a seprate thread(no access to DOM Directly).
They communicate via messages(using postMessage() and onmessage()).

Service Worker (Special Case)
A Service Worker is like a proxy between your web app and the network:
a. Can intercept fetch requests
b. Cache responses for offline access
c. Enable background sync, push notifications.

React Fiber
React Fiber is a complete rewrite of React's core algorithm, introduced in React 16.
It's the new reconciliation engine that fundamentally changed how React handles
updates and rendering.

What is React Fiber?
Fiber refers to both:

The architecture - A new way React schedules and executes work
The data structure - Each component instance is represented as a "fiber" node

Why was Fiber introduced?
Problem with the old React (Stack Reconciler):

->React updates were synchronous and blocking
->Once an update started, it couldn't be interrupted
->Large component trees caused the main thread to be blocked, leading to:
  1) Dropped frames (janky animations)
  2) Unresponsive user interactions
  3) Poor user experience

Key Features of Fiber:
1. Incremental Rendering

1-> Breaks work into small chunks
2-> Can pause, resume, or abort work
3-> Yields control back to the browser between chunks

2. Priority-based Updates

1-> Different types of updates have different priorities:
  a) High Priority: User interactions (clicks, typing)
  b) Low Priority: Data fetching, animations
2-> High-priority updates can interrupt low-priority ones

3. Time Slicing

1-> Work is divided into time slices (typically 5ms)
2-> After each slice, React checks if there are higher-priority tasks
3-> Ensures the browser stays responsive

How Fiber Works:

// Before Fiber (blocking)
function updateComponent() {
  // This would block the main thread until complete
  updateChild1();
  updateChild2();
  updateChild3(); // ... potentially thousands of updates
}

// With Fiber (interruptible)
function fiberUpdateCycle() {
  while (workInProgress && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
  
  if (workInProgress) {
    // More work to do, schedule continuation
    scheduleCallback(flushWork);
  }
}

Fiber Architecture Phases:

Phase 1: Render Phase (Interruptible)
  a) Building the new fiber tree
  b) Calling lifecycle methods like componentWillMount, render
  c) Can be paused and resumed
  d) No side effects

Phase 2: Commit Phase (Synchronous)
  a) Applying changes to the DOM
  b) Calling componentDidMount, componentDidUpdate
  c) Cannot be interrupted
  d) Side effects occur here

Benefits:
1-> Better User Experience
  a) Smooth animations (60fps)
  b) Responsive interactions
  c) No more blocking updates

2-> Better Error Handling
  a) Error boundaries work better
  b) More granular error recovery

3-> Future Features Enabled
  a) Suspense for data fetching
  b) Concurrent rendering
  c) Time slicing

Example of Priority:

// High priority - user interaction
onClick={() => setCounter(counter + 1)}

// Low priority - data fetching
useEffect(() => {
  fetchData().then(setData);
}, []);

React Fiber ensures the button click gets processed immediately, even if data fetching is happening in the background.

Fiber Tree Structure:
Each component becomes a "fiber" node with properties like:

child - first child fiber
sibling - next sibling fiber
return - parent fiber
pendingProps - new props
memoizedProps - previous props
This structure allows React to traverse the tree efficiently and pause/resume work at any node.

React Fiber is the foundation that enables modern React features like Hooks, Suspense, and Concurrent Mode,
making React applications much more performant and user-friendly.

memo()
Use it as high up in the component tree as possible.
-> blocking a component execution there will also block all child component executions.

Checking props with memo() costs performance
-> don't wrap it around all your components -- it will just add a lot of unnecessary checks.

Don't use it on components where props will change frequently
-> memo() would just perform a meaningless check in such cases(which costs performance).

Refs
-> They allow us to access all methods and properties attached to the element.

State vs Refs

State
1-> Causes component re-evaluation(re-execution)
    when changed.
2-> Should be used for values that are directly
    reflected in the UI.
3-> Should not be used for "behind the scenes"
    values that have no direct UI impact.

Refs
1-> Do not cause component re-evaluation when
  changed.
2-> Can be used to gain direct DOM element access
  (great for reading values or accessing certain
  browser APIs).

use vs useContext

useContext
1-> You're on React 18 or earlier.
2-> You only need context.
3-> You want maximum compatibility.

use
1-> You're on React 19+
2-> You need conditional context access.
3-> You're also working with promises/async data.
4-> You want the latest React patterns.

Consuming in Context API
When you access context value in a component and that value then changes
the component function accesses the context value will get re-executed by
React. Just as the component function will also get re-executed if it would
be using some internal state. If it was updated or its parent component 
were executed again.

Just as the component function gets re-executed by React in such
situations it also gets re-excuted if the component function uses
the useContext hook and therefore is connected to some context value
and that value changes and ofcourse the component must be executed again
in such situations because otherwise the UI wouldn't be updated and
that's why React will re-execute component function if its connected
context value changes.

What's a Reducer?
A function that reduce one or more complex values to a simple one.

React features you might not be able to use

1-> React Server Components (RSC)
2-> Server Actions
3-> use() with promises

#important
Special project setup required
Not supported by "standard" React projects (eg-> created via vite)

Why is a Special Setup Needed?
Some features require a server-side environment Code therefore must be
split (by the build process / code bundler process).

Client-side Code
1-> Executed on the client-side
2-> Like in most React projects(eg created via Vite)

Non Client-side Code
1-> Executed on the server-side (or during build process)
2-> Special project setup required.

React Server Components
-> React components that are never executed on the client!
-> Can directly include client-components in their JSX code.

Advantage
1-> less code has to be sent to the client
2-> We can fetch data on the server. Allow us to send finished pages.
3-> Can be async function

Client Components
-> Rendered on the server and client
-> Marked via "use-client" directive
-> Can't directly include client-components in their JSX code.
(if we try to do so it converts server component to client component)

Advantage
1-> Might need to use some client component feature(eg-> useState).

What are Side Effects?
Side Effects are "tasks" that don't impact the current component render cycle.